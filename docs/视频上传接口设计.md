# 视频上传接口详细设计

## 接口概述
实现视频上传的核心功能，支持用户上传视频文件并进行异步转码处理。

## 接口定义

### 1. 视频上传接口

**Endpoint**: `POST /api/v1/videos/upload`

**Headers**:
- `Authorization: Bearer <token>` (必需)
- `Content-Type: multipart/form-data` (必需)

**Request Body (FormData)**:
```
video_file: File (必需，视频文件)
```

**Response**:
```json
{
  "success": true,
  "message": "视频上传成功",
  "data": {
    "video_id": 123,
    "upload_url": "s3://raw-videos/video-123.mp4",
    "status": "pending"
  }
}
```

## 数据库表设计

### Videos 表（补充完整设计）

```sql
-- 创建 Videos 表
CREATE TABLE videos (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '视频标识',
    author_id BIGINT NOT NULL COMMENT '视频作者id，外键到users表',
    play_url VARCHAR(500) DEFAULT NULL COMMENT '视频播放地址',
    cover_url VARCHAR(500) DEFAULT NULL COMMENT '视频封面地址',
    title VARCHAR(200) DEFAULT NULL COMMENT '视频标题',
    description TEXT DEFAULT NULL COMMENT '视频描述',
    duration INT DEFAULT 0 COMMENT '视频时长(秒)',
    file_size BIGINT DEFAULT 0 COMMENT '文件大小(字节)',
    status ENUM('pending', 'processing', 'published', 'failed') DEFAULT 'pending' COMMENT '视频状态',
    favorite_count BIGINT DEFAULT 0 COMMENT '视频点赞数量',
    comment_count BIGINT DEFAULT 0 COMMENT '视频评论数量',
    play_count BIGINT DEFAULT 0 COMMENT '播放次数',
    publish_time BIGINT DEFAULT NULL COMMENT '发布时间(unix timestamp)',
    raw_file_url VARCHAR(500) DEFAULT NULL COMMENT '原始文件地址',
    minio_raw_bucket VARCHAR(100) DEFAULT 'raw-videos' COMMENT 'MinIO原始文件桶',
    minio_public_bucket VARCHAR(100) DEFAULT 'public-videos' COMMENT 'MinIO公共文件桶',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 外键约束
    FOREIGN KEY (author_id) REFERENCES users(id) ON DELETE CASCADE,
    
    -- 索引
    INDEX idx_author_id (author_id),
    INDEX idx_status_publish_time (status, publish_time),
    INDEX idx_publish_time (publish_time)
);

-- 添加 Comments 触发器自动更新 video 表
DELIMITER //
CREATE TRIGGER update_video_comment_count_ins 
    AFTER INSERT ON comments 
    FOR EACH ROW 
BEGIN
    UPDATE videos 
    SET comment_count = comment_count + 1 
    WHERE id = NEW.video_id;
END //

CREATE TRIGGER update_video_comment_count_del 
    AFTER DELETE ON comments 
    FOR EACH ROW 
BEGIN
    UPDATE videos 
    SET comment_count = comment_count - 1 
    WHERE id = OLD.video_id;
END //
DELIMITER ;

-- 添加 Favorites 触发器自动更新 video 表  
DELIMITER //
CREATE TRIGGER update_video_favorite_count_ins
    AFTER INSERT ON favorites
    FOR EACH ROW
BEGIN
    UPDATE videos
    SET favorite_count = favorite_count + 1
    WHERE id = NEW.video_id;
END //

CREATE TRIGGER update_video_favorite_count_del
    AFTER DELETE ON favorites
    FOR EACH ROW
BEGIN
    UPDATE videos
    SET favorite_count = favorite_count - 1
    WHERE id = OLD.video_id;
END //
DELIMITER ;
```

## 核心代码结构

### 1. MinIO 客户端封装

```python
# app/utils/minio_client.py
from minio import Minio
from minio.error import S3Error
from typing import Optional, Tuple
import uuid
import mimetypes
from app.core.config import settings

class MinioClient:
    def __init__(self):
        self.client = Minio(
            settings.MINIO_ENDPOINT,
            access_key=settings.MINIO_ACCESS_KEY,
            secret_key=settings.MINIO_SECRET_KEY,
            secure=settings.MINIO_SECURE
        )
        
        # 确保桶存在
        self._ensure_buckets()
    
    def _ensure_buckets(self):
        """确保必要的桶存在"""
        for bucket in [settings.MINIO_RAW_BUCKET, settings.MINIO_PUBLIC_BUCKET]:
            if not self.client.bucket_exists(bucket):
                self.client.make_bucket(bucket)
    
    def upload_video_file(self, file_obj, original_filename: str, bucket: str = None) -> Tuple[str, str]:
        """上传视频文件到MinIO
        
        Args:
            file_obj: 文件对象
            original_filename: 原始文件名
            bucket: 目标桶名称
            
        Returns:
            (file_url, object_name)
        """
        # 生成唯一的对象名称
        ext = original_filename.split('.')[-1] if '.' in original_filename else 'mp4'
        object_name = f"videos/{uuid.uuid4()}.{ext}"
        
        # 确定桶
        target_bucket = bucket or settings.MINIO_RAW_BUCKET
        
        # 上传文件
        file_obj.seek(0)  # 确保在文件开头
        file_size = file_obj.tell()
        file_obj.seek(0)
        
        self.client.put_object(
            bucket_name=target_bucket,
            object_name=object_name,
            data=file_obj,
            length=file_size,
            content_type=mimetypes.guess_type(original_filename)[0] or 'application/octet-stream'
        )
        
        # 返回文件URL（对于公共桶生成可访问的URL，私有桶返回内部路径）
        if target_bucket == settings.MINIO_PUBLIC_BUCKET:
            file_url = f"{settings.MINIO_PUBLIC_ENDPOINT}/{object_name}"
        else:
            file_url = f"s3://{target_bucket}/{object_name}"
            
        return file_url, object_name
    
    def get_presigned_url(self, object_name: str, bucket: str = None, expires: int = 3600) -> str:
        """获取私有文件的预签名URL"""
        target_bucket = bucket or settings.MINIO_RAW_BUCKET
        return self.client.presigned_get_object(
            bucket_name=target_bucket,
            object_name=object_name,
            expires=expires
        )

# 全局实例
minio_client = MinioClient()
```

### 2. Kafka 生产者封装

```python
# app/utils/kafka_producer.py
from kafka import KafkaProducer
from typing import Dict, Any
import json
from app.core.config import settings

class KafkaProducerClient:
    def __init__(self):
        self.producer = KafkaProducer(
            bootstrap_servers=settings.KAFKA_BOOTSTRAP_SERVERS,
            value_serializer=lambda v: json.dumps(v).encode('utf-8')
        )
    
    def send_transcode_task(self, video_id: int, raw_file_path: str, original_filename: str):
        """发送转码任务消息"""
        task_data = {
            'video_id': video_id,
            'raw_file_path': raw_file_path,
            'original_filename': original_filename,
            'task_type': 'video_transcode'
        }
        
        self.producer.send(
            settings.KAFKA_TRANSCODE_TOPIC,
            value=task_data
        )
        self.producer.flush()

# 全局实例
kafka_producer = KafkaProducerClient()
```

### 3. Pydantic 模型

```python
# app/schemas/request/video_request.py
from pydantic import BaseModel, Field
from typing import Optional

class VideoUploadRequest(BaseModel):
    """视频上传请求模型"""
    title: Optional[str] = Field(
        None,
        max_length=200,
        description="视频标题"
    )
    description: Optional[str] = Field(
        None,
        max_length=1000,
        description="视频描述"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "title": "有趣的视频",
                "description": "这是一个有趣的视频内容"
            }
        }

# app/schemas/response/video_response.py
from typing import Optional, Dict, Any
from app.schemas.response.base_response import BaseResponse

class VideoUploadResponse(BaseResponse):
    """视频上传响应"""
    data: Optional[Dict[str, Any]] = Field(
        None,
        description="上传结果"
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "success": True,
                "message": "视频上传成功",
                "data": {
                    "video_id": 123,
                    "upload_url": "s3://raw-videos/video-123.mp4",
                    "status": "pending"
                }
            }
        }

class VideoInfoResponse(BaseModel):
    """视频信息响应模型"""
    id: int = Field(..., description="视频ID")
    title: Optional[str] = Field(None, description="视频标题")
    description: Optional[str] = Field(None, description="视频描述")
    play_url: Optional[str] = Field(None, description="播放地址")
    cover_url: Optional[str] = Field(None, description="封面地址")
    duration: int = Field(0, description="视频时长(秒)")
    file_size: int = Field(0, description="文件大小(字节)")
    status: str = Field(..., description="视频状态")
    favorite_count: int = Field(0, description="点赞数")
    comment_count: int = Field(0, description="评论数")
    play_count: int = Field(0, description="播放次数")
    publish_time: Optional[int] = Field(None, description="发布时间")
    
    class Config:
        from_attributes = True  # Pydantic v2 兼容性
        json_schema_extra = {
            "example": {
                "id": 123,
                "title": "有趣的视频",
                "play_url": "https://minio-public/video.mp4",
                "status": "published"
            }
        }
```

### 4. CRUD 操作

```python
# app/crud/video_crud.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import Optional
from app.models.video import Video

class VideoCRUD:
    """视频CRUD操作类"""
    
    async def create_video(
        self, 
        db: AsyncSession, 
        author_id: int, 
        raw_file_url: str,
        title: Optional[str] = None,
        description: Optional[str] = None
    ) -> Video:
        """创建视频记录"""
        video = Video(
            author_id=author_id,
            raw_file_url=raw_file_url,
            title=title,
            description=description,
            status='pending'  # 初始状态为pending
        )
        
        db.add(video)
        await db.commit()
        await db.refresh(video)
        return video
    
    async def get_by_id(self, db: AsyncSession, video_id: int) -> Optional[Video]:
        """根据ID获取视频"""
        result = await db.execute(
            select(Video).where(Video.id == video_id)
        )
        return result.scalar_one_or_none()
    
    async def get_published_videos(
        self, 
        db: AsyncSession,
        skip: int = 0, 
        limit: int = 20
    ):
        """获取已发布的视频列表"""
        result = await db.execute(
            select(Video)
            .where(Video.status == 'published')
            .order_by(Video.publish_time.desc())
            .offset(skip)
            .limit(limit)
        )
        return result.scalars().all()
    
    async def update_video_status(
        self, 
        db: AsyncSession, 
        video_id: int, 
        status: str,
        **update_data
    ) -> Optional[Video]:
        """更新视频状态"""
        video = await self.get_by_id(db, video_id)
        if not video:
            return None
            
        video.status = status
        
        # 补充其他字段
        for key, value in update_data.items():
            if hasattr(video, key):
                setattr(video, key, value)
        
        # 如果状态为published，设置发布时间
        if status == 'published' and not video.publish_time:
            import time
            video.publish_time = int(time.time())
        
        await db.commit()
        await db.refresh(video)
        return video

# 全局实例
video_crud = VideoCRUD()
```

### 5. API 接口实现

```python
# app/api/video.py
from fastapi import APIRouter, Depends, UploadFile, File, Form, HTTPException
from typing import Optional
from app.core.dependencies import get_current_user, get_db
from app.models.user import User
from app.crud.video_crud import video_crud
from app.schemas.request.video_request import VideoUploadRequest
from app.schemas.response.video_response import VideoUploadResponse
from app.utils.minio_client import minio_client
from app.utils.kafka_producer import kafka_producer
from sqlalchemy.ext.asyncio import AsyncSession

router = APIRouter(prefix="/api/v1/videos", tags=["视频管理"])

@router.post("/upload", response_model=VideoUploadResponse)
async def upload_video(
    video_file: UploadFile = File(...),
    title: Optional[str] = Form(None),
    description: Optional[str] = Form(None),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """上传视频接口"""
    
    # 1. 文件验证
    if not video_file:
        raise HTTPException(400, "请提供视频文件")
    
    # 验证文件类型
    allowed_types = ['video/mp4', 'video/avi', 'video/mov', 'video/wmv', 'video/flv']
    if video_file.content_type not in allowed_types:
        raise HTTPException(400, "不支持的文件格式，请上传MP4、AVI、MOV等视频文件")
    
    # 2. 上传到MinIO原始文件桶
    try:
        raw_file_url, object_name = minio_client.upload_video_file(
            file_obj=video_file.file,
            original_filename=video_file.filename,
            bucket="raw-videos"
        )
        
        # 3. 创建数据库记录
        video = await video_crud.create_video(
            db=db,
            author_id=current_user.id,
            raw_file_url=raw_file_url,
            title=title,
            description=description
        )
        
        # 4. 发送转码任务到Kafka
        kafka_producer.send_transcode_task(
            video_id=video.id,
            raw_file_path=object_name,
            original_filename=video_file.filename
        )
        
        # 5. 返回成功响应
        return {
            "success": True,
            "message": "视频上传成功",
            "data": {
                "video_id": video.id,
                "upload_url": raw_file_url,
                "status": "pending"
            }
        }
        
    except Exception as e:
        # 记录错误日志
        import logging
        logging.error(f"视频上传失败: {str(e)}")
        raise HTTPException(500, "视频上传失败，请稍后重试")